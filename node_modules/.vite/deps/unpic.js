import "./chunk-UXIASGQL.js";

// node_modules/unpic/esm/data/domains.js
var domains_default = {
  "images.ctfassets.net": "contentful",
  "cdn.builder.io": "builder.io",
  "images.prismic.io": "imgix",
  "www.datocms-assets.com": "imgix",
  "cdn.sanity.io": "imgix",
  "images.unsplash.com": "imgix",
  "cdn.shopify.com": "shopify",
  "s7d1.scene7.com": "scene7",
  "ip.keycdn.com": "keycdn",
  "assets.caisy.io": "bunny",
  "images.contentstack.io": "contentstack"
};

// node_modules/unpic/esm/data/subdomains.js
var subdomains_default = {
  "imgix.net": "imgix",
  "files.wordpress.com": "wordpress",
  "b-cdn.net": "bunny",
  "storyblok.com": "storyblok",
  "kc-usercontent.com": "kontent.ai",
  "cloudinary.com": "cloudinary",
  "kxcdn.com": "keycdn",
  "imgeng.in": "imageengine"
};

// node_modules/unpic/esm/data/paths.js
var paths_default = {
  "/cdn-cgi/image/": "cloudflare",
  "/cdn-cgi/imagedelivery/": "cloudflare_images",
  "/_next/image": "nextjs",
  "/_next/static": "nextjs",
  "/_vercel/image": "vercel",
  "/is/image": "scene7"
};

// node_modules/unpic/esm/src/utils.js
var roundIfNumeric = (value) => {
  if (!value) {
    return value;
  }
  const num = Number(value);
  return isNaN(num) ? value : Math.round(num);
};
var setParamIfDefined = (url, key, value, deleteExisting, roundValue) => {
  if (value) {
    if (roundValue) {
      value = roundIfNumeric(value);
    }
    url.searchParams.set(key, value.toString());
  } else if (deleteExisting) {
    url.searchParams.delete(key);
  }
};
var setParamIfUndefined = (url, key, value) => {
  if (!url.searchParams.has(key)) {
    url.searchParams.set(key, value.toString());
  }
};
var getNumericParam = (url, key) => {
  const value = Number(url.searchParams.get(key));
  return isNaN(value) ? void 0 : value;
};
var toRelativeUrl = (url) => {
  const { pathname, search } = url;
  return `${pathname}${search}`;
};
var toUrl = (url, base) => {
  return typeof url === "string" ? new URL(url, base ?? "http://n/") : url;
};

// node_modules/unpic/esm/src/detect.js
var cdnDomains = new Map(Object.entries(domains_default));
var cdnSubdomains = Object.entries(subdomains_default);
function getImageCdnForUrl(url) {
  return getImageCdnForUrlByDomain(url) || getImageCdnForUrlByPath(url);
}
function getImageCdnForUrlByDomain(url) {
  if (typeof url === "string" && !url.startsWith("https://")) {
    return false;
  }
  const { hostname } = toUrl(url);
  if (cdnDomains.has(hostname)) {
    return cdnDomains.get(hostname);
  }
  for (const [subdomain, cdn] of cdnSubdomains) {
    if (hostname.endsWith(`.${subdomain}`)) {
      return cdn;
    }
  }
  return false;
}
function getImageCdnForUrlByPath(url) {
  const { pathname } = toUrl(url);
  for (const [prefix, cdn] of Object.entries(paths_default)) {
    if (pathname.startsWith(prefix)) {
      return cdn;
    }
  }
  return false;
}

// node_modules/unpic/esm/src/transformers/contentful.js
var parse = (url) => {
  const parsedUrl = toUrl(url);
  const fit = parsedUrl.searchParams.get("fit") || void 0;
  const width = getNumericParam(parsedUrl, "w");
  const height = getNumericParam(parsedUrl, "h");
  const quality = getNumericParam(parsedUrl, "q");
  const format = parsedUrl.searchParams.get("fm") || void 0;
  parsedUrl.search = "";
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { fit, quality },
    cdn: "contentful"
  };
};
var transform = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "w", width, true, true);
  setParamIfDefined(url, "h", height, true, true);
  setParamIfDefined(url, "fm", format);
  setParamIfUndefined(url, "fit", "fill");
  return url;
};

// node_modules/unpic/esm/src/transformers/builder.js
var parse2 = (url) => {
  const parsedUrl = toUrl(url);
  const width = getNumericParam(parsedUrl, "width");
  const height = getNumericParam(parsedUrl, "height");
  const quality = getNumericParam(parsedUrl, "quality");
  const format = parsedUrl.searchParams.get("format") || void 0;
  const fit = parsedUrl.searchParams.get("fit") || void 0;
  parsedUrl.search = "";
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { quality, fit },
    cdn: "builder.io"
  };
};
var transform2 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "width", width, true, true);
  setParamIfDefined(url, "height", height, true, true);
  setParamIfDefined(url, "format", format);
  if (width && height) {
    setParamIfUndefined(url, "fit", "cover");
    setParamIfUndefined(url, "sharp", "true");
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/imgix.js
var parse3 = (url) => {
  const parsed = toUrl(url);
  const width = Number(parsed.searchParams.get("w")) || void 0;
  const height = Number(parsed.searchParams.get("h")) || void 0;
  const quality = Number(parsed.searchParams.get("q")) || void 0;
  const format = parsed.searchParams.get("fm") || void 0;
  const params = {};
  parsed.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  parsed.search = "";
  return {
    base: parsed.toString(),
    width,
    height,
    quality,
    format,
    params,
    cdn: "imgix"
  };
};
var transform3 = ({ url: originalUrl, width, height, format }) => {
  var _a;
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "w", width, true, true);
  setParamIfDefined(url, "h", height, true, true);
  setParamIfUndefined(url, "fit", "min");
  if (format) {
    url.searchParams.set("fm", format);
    const fm = url.searchParams.get("auto");
    if (fm === "format") {
      url.searchParams.delete("auto");
    } else if (fm == null ? void 0 : fm.includes("format")) {
      url.searchParams.set("auto", fm.split(",").filter((s) => s !== "format").join(","));
    }
  } else {
    url.searchParams.delete("fm");
    if (!((_a = url.searchParams.get("auto")) == null ? void 0 : _a.includes("format"))) {
      url.searchParams.append("auto", "format");
    }
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/shopify.js
var shopifyRegex = /(.+?)(?:_(?:(pico|icon|thumb|small|compact|medium|large|grande|original|master)|(\d*)x(\d*)))?(?:_crop_([a-z]+))?(\.[a-zA-Z]+)(\.png|\.jpg|\.webp|\.avif)?$/;
var parse4 = (imageUrl) => {
  const url = toUrl(imageUrl);
  const match = url.pathname.match(shopifyRegex);
  if (!match) {
    throw new Error("Invalid Shopify URL");
  }
  const [, path, size, width, height, crop, extension, format] = match;
  url.pathname = `${path}${extension}`;
  const widthString = width ? width : url.searchParams.get("width");
  const heightString = height ? height : url.searchParams.get("height");
  url.searchParams.delete("width");
  url.searchParams.delete("height");
  return {
    base: url.toString(),
    width: Number(widthString) || void 0,
    height: Number(heightString) || void 0,
    format: format ? format.slice(1) : void 0,
    params: { crop, size },
    cdn: "shopify"
  };
};
var generate = ({ base, width, height, format, params }) => {
  const url = toUrl(base);
  setParamIfDefined(url, "width", width, true, true);
  setParamIfDefined(url, "height", height, true, true);
  setParamIfDefined(url, "crop", params == null ? void 0 : params.crop);
  setParamIfDefined(url, "format", format);
  return url;
};
var transform4 = ({ url: originalUrl, width, height }) => {
  const parsed = parse4(originalUrl);
  if (!parsed) {
    return;
  }
  const props = {
    ...parsed,
    width,
    height
  };
  return generate(props);
};

// node_modules/unpic/esm/src/transformers/wordpress.js
var transform5 = ({ url: originalUrl, width, height }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "w", width, true, true);
  setParamIfDefined(url, "h", height, true, true);
  setParamIfUndefined(url, "crop", "1");
  return url;
};
var parse5 = (url) => {
  const parsed = toUrl(url);
  const width = getNumericParam(parsed, "w");
  const height = getNumericParam(parsed, "h");
  const crop = parsed.searchParams.get("crop") === "1";
  parsed.search = "";
  return {
    base: parsed.toString(),
    width,
    height,
    params: { crop },
    cdn: "wordpress"
  };
};

// node_modules/unpic/esm/src/transformers/cloudinary.js
var cloudinaryRegex = /https?:\/\/(?<host>[^\/]+)\/(?<cloudName>[^\/]+)\/(?<assetType>image|video|raw)\/(?<deliveryType>upload|fetch|private|authenticated|sprite|facebook|twitter|youtube|vimeo)\/?(?<signature>s\-\-[a-zA-Z0-9]+\-\-)?\/?(?<transformations>(?:[^_\/]+_[^,\/]+,?)*)?\/(?:(?<version>v\d+)\/)?(?<idAndFormat>[^\s]+)$/g;
var parseTransforms = (transformations) => {
  return transformations ? Object.fromEntries(transformations.split(",").map((t) => t.split("_"))) : {};
};
var formatUrl = ({ host, cloudName, assetType, deliveryType, signature, transformations = {}, version, id, format }) => {
  if (format) {
    transformations.f = format;
  }
  const transformString = Object.entries(transformations).map(([key, value]) => `${key}_${value}`).join(",");
  const pathSegments = [
    host,
    cloudName,
    assetType,
    deliveryType,
    signature,
    transformString,
    version,
    id
  ].filter(Boolean).join("/");
  return `https://${pathSegments}`;
};
var parse6 = (imageUrl) => {
  const url = toUrl(imageUrl);
  const matches = [...url.toString().matchAll(cloudinaryRegex)];
  if (!matches.length) {
    throw new Error("Invalid Cloudinary URL");
  }
  const group = matches[0].groups || {};
  const { transformations: transformString = "", idAndFormat, ...baseParams } = group;
  delete group.idAndFormat;
  const lastDotIndex = idAndFormat.lastIndexOf(".");
  const id = lastDotIndex < 0 ? idAndFormat : idAndFormat.slice(0, lastDotIndex);
  const originalFormat = lastDotIndex < 0 ? void 0 : idAndFormat.slice(lastDotIndex + 1);
  const { w, h, f, ...transformations } = parseTransforms(transformString);
  const format = f && f !== "auto" ? f : originalFormat;
  const base = formatUrl({ ...baseParams, id, transformations });
  return {
    base,
    width: Number(w) || void 0,
    height: Number(h) || void 0,
    format,
    cdn: "cloudinary",
    params: {
      ...group,
      id: group.deliveryType === "fetch" ? idAndFormat : id,
      format,
      transformations
    }
  };
};
var generate2 = ({ base, width, height, format, params }) => {
  var _a;
  const parsed = parse6(base.toString());
  const props = {
    transformations: {},
    ...parsed.params,
    ...params,
    format: format || "auto"
  };
  if (width) {
    props.transformations.w = roundIfNumeric(width).toString();
  }
  if (height) {
    props.transformations.h = roundIfNumeric(height).toString();
  }
  (_a = props.transformations).c || (_a.c = "lfill");
  return formatUrl(props);
};
var transform6 = ({ url: originalUrl, width, height, format = "auto" }) => {
  var _a, _b;
  const parsed = parse6(originalUrl);
  if (!parsed) {
    throw new Error("Invalid Cloudinary URL");
  }
  if (((_a = parsed.params) == null ? void 0 : _a.assetType) !== "image") {
    throw new Error("Cloudinary transformer only supports images");
  }
  if ((_b = parsed.params) == null ? void 0 : _b.signature) {
    throw new Error("Cloudinary transformer does not support signed URLs");
  }
  const props = {
    ...parsed,
    width,
    height,
    format
  };
  return generate2(props);
};

// node_modules/unpic/esm/src/transformers/cloudflare.js
var cloudflareRegex = /https?:\/\/(?<host>[^\/]+)\/cdn-cgi\/image\/(?<transformations>[^\/]+)\/(?<path>.*)$/g;
var parseTransforms2 = (transformations) => Object.fromEntries(transformations.split(",").map((t) => t.split("=")));
var formatUrl2 = ({ host, transformations = {}, path }) => {
  const transformString = Object.entries(transformations).map(([key, value]) => `${key}=${value}`).join(",");
  const pathSegments = [
    host,
    "cdn-cgi",
    "image",
    transformString,
    path
  ].join("/");
  return `https://${pathSegments}`;
};
var parse7 = (imageUrl) => {
  const url = toUrl(imageUrl);
  const matches = [...url.toString().matchAll(cloudflareRegex)];
  if (!matches.length) {
    throw new Error("Invalid Cloudflare URL");
  }
  const group = matches[0].groups || {};
  const { transformations: transformString, ...baseParams } = group;
  const { width, height, f, ...transformations } = parseTransforms2(transformString);
  const base = formatUrl2({ ...baseParams, transformations });
  return {
    base: url.toString(),
    width: Number(width) || void 0,
    height: Number(height) || void 0,
    format: f,
    cdn: "cloudflare",
    params: { ...group, transformations }
  };
};
var generate3 = ({ base, width, height, format, params }) => {
  var _a;
  const parsed = parse7(base.toString());
  const props = {
    transformations: {},
    ...parsed.params,
    ...params
  };
  if (width) {
    props.transformations.width = width == null ? void 0 : width.toString();
  }
  if (height) {
    props.transformations.height = height == null ? void 0 : height.toString();
  }
  if (format) {
    props.transformations.f = format;
  }
  (_a = props.transformations).fit || (_a.fit = "cover");
  return new URL(formatUrl2(props));
};
var transform7 = ({ url: originalUrl, width, height, format = "auto" }) => {
  const parsed = parse7(originalUrl);
  if (!parsed) {
    throw new Error("Invalid Cloudflare URL");
  }
  const props = {
    ...parsed,
    width,
    height,
    format
  };
  return generate3(props);
};

// node_modules/unpic/esm/src/transformers/bunny.js
var parse8 = (url) => {
  const parsedUrl = toUrl(url);
  const width = getNumericParam(parsedUrl, "width");
  const height = getNumericParam(parsedUrl, "height");
  const params = {};
  parsedUrl.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  parsedUrl.search = "";
  return {
    width,
    height,
    base: parsedUrl.toString(),
    params,
    cdn: "bunny"
  };
};
var transform8 = ({ url: originalUrl, width, height }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "width", width, true, true);
  if (width && height) {
    setParamIfUndefined(url, "aspect_ratio", `${width}:${height}`);
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/storyblok.js
var storyBlokAssets = /(?<id>\/f\/\d+\/\d+x\d+\/\w+\/[^\/]+)\/?(?<modifiers>m\/?(?<crop>\d+x\d+:\d+x\d+)?\/?(?<resize>(?<flipx>\-)?(?<width>\d+)x(?<flipy>\-)?(?<height>\d+))?\/?(filters\:(?<filters>[^\/]+))?)?$/g;
var storyBlokImg2 = /^(?<modifiers>\/(?<crop>\d+x\d+:\d+x\d+)?\/?(?<resize>(?<flipx>\-)?(?<width>\d+)x(?<flipy>\-)?(?<height>\d+))?\/?(filters\:(?<filters>[^\/]+))?\/?)?(?<id>\/f\/.+)$/g;
var splitFilters = (filters) => {
  if (!filters) {
    return {};
  }
  return Object.fromEntries(filters.split(":").map((filter) => {
    if (!filter)
      return [];
    const [key, value] = filter.split("(");
    return [key, value.replace(")", "")];
  }));
};
var generateFilters = (filters) => {
  if (!filters) {
    return void 0;
  }
  const filterItems = Object.entries(filters).map(([key, value]) => `${key}(${value ?? ""})`);
  if (filterItems.length === 0) {
    return void 0;
  }
  return `filters:${filterItems.join(":")}`;
};
var parse9 = (imageUrl) => {
  const url = toUrl(imageUrl);
  const regex = url.hostname === "img2.storyblok.com" ? storyBlokImg2 : storyBlokAssets;
  const [matches] = url.pathname.matchAll(regex);
  if (!matches || !matches.groups) {
    throw new Error("Invalid Storyblok URL");
  }
  const { id, crop, width, height, filters, flipx, flipy } = matches.groups;
  const { format, ...filterMap } = splitFilters(filters);
  if (url.hostname === "img2.storyblok.com") {
    url.hostname = "a.storyblok.com";
  }
  return {
    base: url.origin + id,
    width: Number(width) || void 0,
    height: Number(height) || void 0,
    format,
    params: {
      crop,
      filters: filterMap,
      flipx,
      flipy
    },
    cdn: "storyblok"
  };
};
var generate4 = ({ base, width = 0, height = 0, format, params = {} }) => {
  const { crop, filters, flipx = "", flipy = "" } = params;
  const size = `${flipx}${width}x${flipy}${height}`;
  return new URL([base, "m", crop, size, generateFilters(filters), format].filter(Boolean).join("/"));
};
var transform9 = ({ url: originalUrl, width, height, format }) => {
  const parsed = parse9(originalUrl);
  if (!parsed) {
    return;
  }
  if (format) {
    if (!parsed.params) {
      parsed.params = { filters: {} };
    }
    if (!parsed.params.filters) {
      parsed.params.filters = {};
    }
    parsed.params.filters.format = format;
  }
  return generate4({
    ...parsed,
    width,
    height
  });
};

// node_modules/unpic/esm/src/transformers/kontentai.js
var parse10 = (url) => {
  const parsedUrl = toUrl(url);
  const fit = parsedUrl.searchParams.get("fit") || void 0;
  const width = getNumericParam(parsedUrl, "w");
  const height = getNumericParam(parsedUrl, "h");
  const quality = getNumericParam(parsedUrl, "q");
  const format = parsedUrl.searchParams.get("fm") || void 0;
  parsedUrl.search = "";
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { fit, quality },
    cdn: "kontent.ai"
  };
};
var transform10 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "w", width, true, true);
  setParamIfDefined(url, "h", height, true, true);
  setParamIfDefined(url, "fm", format, true);
  if (width && height) {
    setParamIfUndefined(url, "fit", "crop");
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/vercel.js
var parse11 = (url) => {
  const parsed = toUrl(url);
  const width = Number(parsed.searchParams.get("w")) || void 0;
  const quality = Number(parsed.searchParams.get("q")) || void 0;
  return {
    base: parsed.toString(),
    width,
    quality,
    cdn: "vercel"
  };
};
var delegateUrl = (url) => {
  const parsed = toUrl(url);
  const source = parsed.searchParams.get("url");
  if (!source || !source.startsWith("http")) {
    return false;
  }
  const cdn = getImageCdnForUrlByDomain(source);
  if (!cdn) {
    return false;
  }
  return {
    cdn,
    url: source
  };
};
var generate5 = ({ base, width, params: { quality = 75, root = "_vercel" } = {} }) => {
  const url = new URL("http://n");
  url.pathname = `/${root}/image`;
  url.searchParams.set("url", base.toString());
  setParamIfDefined(url, "w", width, false, true);
  setParamIfUndefined(url, "q", quality);
  return toRelativeUrl(url);
};
var transform11 = ({ url, width, cdn }) => {
  const parsedUrl = toUrl(url);
  const isNextImage = parsedUrl.pathname.startsWith("/_next/image") || parsedUrl.pathname.startsWith("/_vercel/image");
  const src = isNextImage ? parsedUrl.searchParams.get("url") : url.toString();
  if (!src) {
    return void 0;
  }
  setParamIfDefined(parsedUrl, "w", width, true, true);
  if (isNextImage) {
    if (parsedUrl.hostname === "n") {
      return toRelativeUrl(parsedUrl);
    }
    return parsedUrl.toString();
  }
  return generate5({
    base: src,
    width,
    params: { root: cdn === "nextjs" ? "_next" : "_vercel" }
  });
};

// node_modules/unpic/esm/src/transformers/nextjs.js
var parse12 = (url) => ({ ...parse11(url), cdn: "nextjs" });
var transform12 = (params) => transform11({ ...params, cdn: "nextjs" });

// node_modules/unpic/esm/src/transformers/scene7.js
var parse13 = (url) => {
  const parsedUrl = toUrl(url);
  const fit = parsedUrl.searchParams.get("fit") || void 0;
  const width = getNumericParam(parsedUrl, "wid");
  const height = getNumericParam(parsedUrl, "hei");
  const quality = getNumericParam(parsedUrl, "qlt") || void 0;
  const format = parsedUrl.searchParams.get("fmt") || void 0;
  const scale = getNumericParam(parsedUrl, "scl") || void 0;
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { fit, quality, scale },
    cdn: "scene7"
  };
};
var transform13 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "wid", width, true, true);
  setParamIfDefined(url, "hei", height, true, true);
  setParamIfDefined(url, "fmt", format, true);
  setParamIfDefined(url, "qlt", getNumericParam(url, "qlt"), true);
  setParamIfDefined(url, "scl", getNumericParam(url, "scl"), true);
  setParamIfUndefined(url, "fit", "crop");
  if (!width && !height) {
    setParamIfUndefined(url, "scl", 1);
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/keycdn.js
var parse14 = (url) => {
  const parsedUrl = toUrl(url);
  const width = getNumericParam(parsedUrl, "width");
  const height = getNumericParam(parsedUrl, "height");
  const format = parsedUrl.searchParams.get("format") || void 0;
  const quality = getNumericParam(parsedUrl, "quality") || void 0;
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { quality },
    cdn: "keycdn"
  };
};
var transform14 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "width", width, true, true);
  setParamIfDefined(url, "height", height, true, true);
  setParamIfDefined(url, "format", format, true);
  setParamIfDefined(url, "quality", getNumericParam(url, "quality"), true);
  setParamIfUndefined(url, "enlarge", 0);
  return url;
};

// node_modules/unpic/esm/src/transformers/directus.js
var parse15 = (imageUrl) => {
  const parsedUrl = toUrl(imageUrl);
  const width = getNumericParam(parsedUrl, "width");
  const height = getNumericParam(parsedUrl, "height");
  const format = parsedUrl.searchParams.get("format") || void 0;
  const quality = getNumericParam(parsedUrl, "quality") || void 0;
  let fit = parsedUrl.searchParams.get("fit") || void 0;
  const withoutEnlargement = parsedUrl.searchParams.get("withoutEnlargement") === "true" || void 0;
  const transforms = parsedUrl.searchParams.get("transforms") || void 0;
  if (fit && !["cover", "contain", "inside", "outside"].includes(fit)) {
    fit = void 0;
  }
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: {
      fit,
      quality,
      withoutEnlargement,
      transforms: transforms ? JSON.parse(transforms) : void 0
    },
    cdn: "directus"
  };
};
var transform15 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "width", width, true, true);
  setParamIfDefined(url, "height", height, true, true);
  setParamIfDefined(url, "format", format);
  setParamIfDefined(url, "quality", getNumericParam(url, "quality"), true);
  return url;
};

// node_modules/unpic/esm/src/transformers/imageengine.js
var OBJECT_TO_DIRECTIVES_MAP = {
  width: "w",
  height: "h",
  autoWidthWithFallback: "w_auto",
  auto_width_fallback: "w_auto",
  scaleToScreenWidth: "pc",
  scale_to_screen_width: "pc",
  crop: "cr",
  outputFormat: "f",
  format: "f",
  fit: "m",
  fitMethod: "m",
  compression: "cmpr",
  sharpness: "s",
  rotate: "r",
  inline: "in",
  keepMeta: "meta",
  keep_meta: "meta",
  noOptimization: "pass",
  no_optimization: "pass",
  force_download: "dl",
  max_device_pixel_ratio: "maxdpr",
  maxDevicePixelRatio: "maxdpr"
};
var parse16 = (imageUrl) => {
  const parsedUrl = toUrl(imageUrl);
  const paramArray = getParameterArray(parsedUrl);
  const baseUrl = getBaseUrl(parsedUrl);
  let width = void 0, height = void 0, format = void 0;
  const params = {};
  if (paramArray.length > 0) {
    paramArray.forEach((para) => {
      let key_value = para.split("_");
      if (key_value.length > 1) {
        switch (key_value[0]) {
          case "w":
            width = Number(key_value[1]);
            break;
          case "h":
            height = Number(key_value[1]);
            break;
          case "f":
            format = key_value[1];
            break;
          default:
            if (Object.values(OBJECT_TO_DIRECTIVES_MAP).includes(key_value[0])) {
              let directive = getDirective(key_value[0]);
              params[directive] = key_value[1];
            }
        }
      }
    });
  }
  return {
    base: baseUrl,
    width,
    height,
    format,
    params,
    cdn: "imageengine"
  };
};
function getDirective(key) {
  let keyArray = Object.keys(OBJECT_TO_DIRECTIVES_MAP);
  let directive = keyArray.find((k) => OBJECT_TO_DIRECTIVES_MAP[k] === key) || "";
  return directive;
}
function getParameterArray(url) {
  let url_string = url.toString();
  let paramArray = [];
  if (url_string) {
    let splitURL = url_string.split("imgeng=");
    if (splitURL.length > 1) {
      paramArray = splitURL[1].split("/");
    }
  }
  return paramArray;
}
function getBaseUrl(url) {
  let url_string = url.toString();
  let baseUrl = "";
  if (url_string) {
    let splitURL = url_string.split("imgeng=");
    if (splitURL.length > 1) {
      baseUrl = splitURL[0].slice(0, -1);
    } else
      baseUrl = url_string;
  }
  return baseUrl;
}
var transform16 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  const src = getBaseUrl(url);
  let directives = {};
  const param = url.toString() === src ? [] : getParameterArray(url);
  if (param.length) {
    directives = getDirectives(param);
  }
  if (width)
    directives["width"] = width;
  if (height)
    directives["height"] = height;
  if (format)
    directives["format"] = format;
  if (!directives.hasOwnProperty("fit")) {
    directives = { ...directives, "fit": "cropbox" };
  }
  let directives_string = build_IE_directives(directives);
  let query_string = build_IE_query_string(directives_string);
  let query_prefix = query_string === "" ? "" : src.includes("?") ? "&" : "?";
  return `${src}${query_prefix}${query_string}`;
};
function build_IE_directives(directives) {
  return Object.entries(directives).reduce((acc, [k, v]) => {
    return acc + maybe_create_directive(k, v);
  }, "");
}
function build_IE_query_string(directives_string) {
  if (directives_string && directives_string !== "") {
    return `imgeng=${directives_string}`;
  }
  return "";
}
function maybe_create_directive(directive, value) {
  let translated_directive = OBJECT_TO_DIRECTIVES_MAP[directive];
  if (translated_directive && (value || value === 0)) {
    return `/${translated_directive}_${value}`;
  }
  return "";
}
function getDirectives(paramArray) {
  let directives = {};
  paramArray.forEach((para) => {
    let keyValue = para.split("_");
    if (keyValue.length > 1) {
      let key = keyValue[0];
      let value = keyValue[1];
      let directiveKey = getDirective(key);
      if (directiveKey) {
        directives[directiveKey] = value;
      }
    }
  });
  return directives;
}

// node_modules/unpic/esm/src/transformers/contentstack.js
var parse17 = (url) => {
  const parsedUrl = toUrl(url);
  const fit = parsedUrl.searchParams.get("fit") || void 0;
  const width = getNumericParam(parsedUrl, "width");
  const height = getNumericParam(parsedUrl, "height");
  const quality = getNumericParam(parsedUrl, "quality");
  const format = parsedUrl.searchParams.get("format") || void 0;
  parsedUrl.search = "";
  return {
    width,
    height,
    format,
    base: parsedUrl.toString(),
    params: { fit, quality },
    cdn: "contentstack"
  };
};
var transform17 = ({ url: originalUrl, width, height, format }) => {
  const url = toUrl(originalUrl);
  setParamIfDefined(url, "width", width, true, true);
  setParamIfDefined(url, "height", height, true, true);
  setParamIfDefined(url, "format", format);
  if (!url.searchParams.has("format")) {
    setParamIfUndefined(url, "auto", "webp");
  }
  if (width && height) {
    setParamIfUndefined(url, "fit", "crop");
  }
  return url;
};

// node_modules/unpic/esm/src/transformers/cloudflareimages.js
var cloudflareImagesRegex = /https?:\/\/(?<host>[^\/]+)\/cdn-cgi\/imagedelivery\/(?<accountHash>[^\/]+)\/(?<imageId>[^\/]+)\/*(?<transformations>[^\/]+)*$/g;
var parseTransforms3 = (transformations) => {
  var _a;
  return Object.fromEntries(((_a = transformations == null ? void 0 : transformations.split(",")) == null ? void 0 : _a.map((t) => t.split("="))) ?? []);
};
var formatUrl3 = ({ host, accountHash, transformations = {}, imageId }) => {
  const transformString = Object.entries(transformations).map(([key, value]) => `${key}=${value}`).join(",");
  const pathSegments = [
    host,
    "cdn-cgi",
    "imagedelivery",
    accountHash,
    imageId,
    transformString
  ].join("/");
  return `https://${pathSegments}`;
};
var parse18 = (imageUrl) => {
  const url = toUrl(imageUrl);
  const matches = [...url.toString().matchAll(cloudflareImagesRegex)];
  if (!matches.length) {
    throw new Error("Invalid Cloudflare Images URL");
  }
  const group = matches[0].groups || {};
  const { transformations: transformString, ...baseParams } = group;
  const { w, h, f, ...transformations } = parseTransforms3(transformString);
  return {
    base: url.toString(),
    width: Number(w) || void 0,
    height: Number(h) || void 0,
    format: f,
    cdn: "cloudflare_images",
    params: { ...baseParams, transformations }
  };
};
var generate6 = ({ base, width, height, format, params }) => {
  var _a;
  const parsed = parse18(base.toString());
  const props = {
    transformations: {},
    ...parsed.params,
    ...params
  };
  if (width) {
    props.transformations.w = width == null ? void 0 : width.toString();
  }
  if (height) {
    props.transformations.h = height == null ? void 0 : height.toString();
  }
  if (format) {
    props.transformations.f = format;
  }
  (_a = props.transformations).fit || (_a.fit = "cover");
  return new URL(formatUrl3(props));
};
var transform18 = ({ url: originalUrl, width, height, format = "auto" }) => {
  const parsed = parse18(originalUrl);
  if (!parsed) {
    throw new Error("Invalid Cloudflare Images URL");
  }
  const props = {
    ...parsed,
    width,
    height,
    format
  };
  return generate6(props);
};

// node_modules/unpic/esm/src/canonical.js
var delegators = {
  vercel: delegateUrl,
  nextjs: delegateUrl
};
function getDelegatedCdn(url, cdn) {
  if (!(cdn in delegators)) {
    return false;
  }
  const maybeDelegate = delegators[cdn];
  if (!maybeDelegate) {
    return false;
  }
  return maybeDelegate(url);
}
function getCanonicalCdnForUrl(url, defaultCdn) {
  const cdn = getImageCdnForUrl(url) || defaultCdn;
  if (!cdn) {
    return false;
  }
  const maybeDelegated = getDelegatedCdn(url, cdn);
  if (maybeDelegated) {
    return maybeDelegated;
  }
  return { cdn, url };
}

// node_modules/unpic/esm/src/transform.js
var getTransformer = (cdn) => ({
  imgix: transform3,
  contentful: transform,
  "builder.io": transform2,
  shopify: transform4,
  wordpress: transform5,
  cloudinary: transform6,
  bunny: transform8,
  storyblok: transform9,
  cloudflare: transform7,
  vercel: transform11,
  nextjs: transform12,
  scene7: transform13,
  "kontent.ai": transform10,
  keycdn: transform14,
  directus: transform15,
  imageengine: transform16,
  contentstack: transform17,
  "cloudflare_images": transform18
})[cdn];
var getTransformerForCdn = (cdn) => {
  if (!cdn) {
    return void 0;
  }
  return getTransformer(cdn);
};
var transformUrl = (options) => {
  var _a, _b;
  const cdn = (options == null ? void 0 : options.cdn) ?? getImageCdnForUrl(options.url);
  if (!(options.recursive ?? true)) {
    return (_a = getTransformerForCdn(cdn)) == null ? void 0 : _a(options);
  }
  const canonical = getCanonicalCdnForUrl(options.url, cdn);
  if (!canonical || !canonical.cdn) {
    return void 0;
  }
  return (_b = getTransformer(canonical.cdn)) == null ? void 0 : _b({
    ...options,
    url: canonical.url
  });
};
var getTransformerForUrl = (url) => getTransformerForCdn(getImageCdnForUrl(url));

// node_modules/unpic/esm/src/parse.js
var parsers = {
  imgix: parse3,
  contentful: parse,
  "builder.io": parse2,
  shopify: parse4,
  wordpress: parse5,
  cloudinary: parse6,
  cloudflare: parse7,
  bunny: parse8,
  storyblok: parse9,
  "kontent.ai": parse10,
  vercel: parse11,
  nextjs: parse12,
  scene7: parse13,
  keycdn: parse14,
  directus: parse15,
  imageengine: parse16,
  contentstack: parse17,
  "cloudflare_images": parse18
};
var cdnIsSupportedForParse = (cdn) => cdn && cdn in parsers;
var getParserForUrl = (url) => getParserForCdn(getImageCdnForUrl(url));
var getParserForCdn = (cdn) => {
  if (!cdn || !cdnIsSupportedForParse(cdn)) {
    return void 0;
  }
  return parsers[cdn];
};
var parseUrl = (url, cdn) => {
  var _a, _b;
  if (cdn) {
    return (_a = getParserForCdn(cdn)) == null ? void 0 : _a(url);
  }
  const detectedCdn = getImageCdnForUrl(url);
  if (!detectedCdn) {
    return void 0;
  }
  if (!cdnIsSupportedForParse(detectedCdn)) {
    return { cdn: detectedCdn, base: url.toString() };
  }
  return (_b = getParserForCdn(detectedCdn)) == null ? void 0 : _b(url);
};
export {
  cdnIsSupportedForParse,
  getCanonicalCdnForUrl,
  getDelegatedCdn,
  getImageCdnForUrl,
  getImageCdnForUrlByDomain,
  getImageCdnForUrlByPath,
  getParserForCdn,
  getParserForUrl,
  getTransformer,
  getTransformerForCdn,
  getTransformerForUrl,
  parseUrl,
  parsers,
  transformUrl
};
//# sourceMappingURL=unpic.js.map
